#include <stdio.h>
#include <math.h>

int main() {

    comb1(); // вызываем функцию с первым вариантом сортировки расчёской
    printf("%s \n", "------");
    comb2(); // второй вариант сортировки

    return 0;
}

int comb1() { // в теле этого метода осуществляется сортировка с использованием параметрических циклов

    int i, t, step; // объявляем счётчик, вспомогательную переменную, шаг
    int array[] = { 7, -2, 0, 383, 6, 56, 15, -94 };
    int n = sizeof(array) / sizeof(int); // размер массива 
    float k = 1.247; // фактор уменьшения 

    for (step = n - 1; step >= 1; step /= k) // внешний цикл проходит от наибольшего значения шага до наименьшего, равного единице 
        for (i = 0; i < n - step; i++) // внутренний цикл идёт от начала массива и до значения под номером n - step
            if (array[i] > array[i + step]) { // сравниваем i-тый элемент и элемент c индексом i + step
                t = array[i]; // тут используем вспомогательную переменную
                array[i] = array[i + step]; // если a[i] > a[i + step], меняем их местами 
                array[i + step] = t; // и тут тоже используем вспомогательную переменную
            }

    for (i = 0; i < n; i++) { // выводим отсортированный массив
        printf("%d \n", array[i]);
    }
}

int comb2() { // реализуем вариант сортировки с помощью циклов с предусловием 

    int i, t; 
    int array[] = { 7, -2, 0, 383, 6, 56, 15, -94 };
    int n = sizeof(array) / sizeof(int);
    float k = 1.247;
    int step = n - 1;

    while (step >= 1) { // тут уже используем цикл с предусловием 
        i = 0; // обнуляем i
        while (i < n - step) { // входим во внутренний цикл
            if (array[i] > array[i + step]) { // условная конструкция аналогична конструкции в методе comb1()
                t = array[i];
                array[i] = array[i + step]; 
                array[i + step] = t;
            }
            i++; // инкрементируем итератор внутреннего цикла 
        }
        step /= k; // уменьшаем шаг делением на k
    }

    for (i = 0; i < n; i++) { // второй раз выводим массив, результат тот же
        printf("%d \n", array[i]);
    }
}


/*
int main() {

    choice1(); // вызываем функцию с первым вариантом сортировки выбором
    printf("%s \n", "------");
    choice2(); // второй вариант сортировки

    return 0;
}

int choice1() { // цикл с предусловием 
    int i = 0, j, min, buf, N = 7; // объявление переменных
    int arr[] = { 6, 4, 1, 5, 3, 7, 2 }; // объявления массива
    while (i < N - 1) { // внешний цикл
        j = i + 1; // j всегда равен следующем полсе i элементу
        min = i; // принимаем i-тый элемент за минимум
        while (j < N) { // внутренний цикл
            if (arr[j] < arr[min]) // сравнение элемента j и min
                min = j; // двигаем элементы
            j++; // инкремент внутреннего цикла
        }

        // тут меняем элементы местами
        buf = arr[i];
        arr[i] = arr[min];
        arr[min] = buf;
        i++; // инкремент внешнего цикла
    }

    for (i = 0; i < N; i++) // вывод массива
        printf("%d ", arr[i]);

    return 0;

}


int choice2() { // параметрический цикл

    int i, j, min, buf, N = 7; // объявление переменных
    int arr[] = { 6, 4, 1, 5, 3, 7, 2 }; // объявления массива
    for (i = 0; i < N - 1; i++) { // внешний цикл
        for (j = i + 1, min = i; j < N; j++) { // внутренний цикл
            if (arr[j] < arr[min]) // сравнение элемента j и min
                min = j; // двигаем элементы
        }

        // тут меняем элементы местами
        buf = arr[i];
        arr[i] = arr[min];
        arr[min] = buf;
    }

    for (i = 0; i < N; i++) // вывод
        printf("%d ", arr[i]);

    return 0;
}
*/
